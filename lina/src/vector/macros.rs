//! All macro implementations
//!
//! All macro_rules definitions and use should be placed into this file.
//! This way we don't need to handle with the mess of exporting/importing the
//! macros within the crate and the "cycle detected" compiler error.
//! In this error if macro A depends on the code generated by macro B, then the
//! compiler will enter a loop, trying to determine the bounds are satisfied.
//! The issue does not appear if the macro invocations for both A and B appear
//! in the same file.
use crate::vector::Sqrt;
use crate::vector::Vector;

/// Generate a [Vector](crate::vector::Vector) similar to the [vec!] macro.
///
/// It has three forms.
///  - A convenience/reference default initialization
/// ```
/// use lina::vector::{Vector, v};
///
/// let preferred: Vector::<usize, 3> = v![];
/// let over = Vector::<usize, 3>::new();
/// ```
///
///  - Create a [Vector](crate::vector::Vector) with default value D and N elements
/// ```
/// use lina::vector::v;
///
/// let V = v![3; 4];
/// assert_eq!(V, [3, 3, 3, 3]);
/// ```
///
/// - Create a [Vector](crate::vector::Vector) from a list of values
/// ```
/// use lina::vector::v;
///
/// let V = v![1,2,3,4,5];
/// assert_eq!(V, [1,2,3,4,5]);
/// ```
#[macro_export]
macro_rules! v {
    () => {
        $crate::vector::Vector::new()
    };
    ($default_value:expr; $n:expr) => {
        $crate::vector::Vector::<_, $n>::from_value($default_value)
    };
    ($($element:expr),+$(,)?) => {
        $crate::vector::Vector::from_array([$($element),+])
    }
}

// Re-export the macro, avoiding the need for #[macro_use].
pub use v;

/// Cross product for 3D Vectors
///
/// As far as I could see a cross product only exists in 3 and 7 dimensions,
/// but for now support for only three is enough.
macro_rules! cross_product_impl {
    ($($T: ty),* $(,)*) => {$(
        impl Vector<$T, 3> {
            pub fn cross(self, rhs: Vector<$T, 3>) -> Vector<$T, 3> {
                use crate::v;
                v![
                    self.data[1] * rhs.data[2] - self.data[2] * rhs.data[1],
                    self.data[2] * rhs.data[0] - self.data[0] * rhs.data[2],
                    self.data[0] * rhs.data[1] - self.data[1] * rhs.data[0]
                ]
            }
        }
    )*};
}

cross_product_impl!(
    u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize, f32, f64
);

// Implement the LHS scalar multiplication operators for built in types.
// For custom types the user must provide the implementation given the Orphan rule.

macro_rules! lhs_scalar_mul_impl {
    ($($T: ty),* $(,)*) => {$(
        impl<const LENGTH: usize> std::ops::Mul<Vector<$T, LENGTH>> for $T
        where
            Vector<$T, LENGTH>: std::ops::Mul<$T, Output = Vector<$T, LENGTH>>,
        {
            type Output = Vector<$T, LENGTH>;

            /// Perform the `T * Vector<T>` operation
            fn mul(self, rhs: Vector<$T, LENGTH>) -> Self::Output {
                rhs * self
            }
        }
    )*};
}

lhs_scalar_mul_impl!(
    u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize, f32, f64
);

// Implement for built in floating point types
macro_rules! impl_sqrt_for_float_types {
    ($($T: ty),* $(,)*) => {$(
        impl Sqrt for $T
        {
            type Output = $T;

            fn square_root(self) -> Self::Output {
                self.sqrt()
            }
        }
    )*};
}

impl_sqrt_for_float_types!(f32, f64);

macro_rules! impl_neg_trait {
   ($($T: ty),* $(,)*) => {$(
        impl<const LENGTH: usize> std::ops::Neg for Vector<$T, LENGTH>
        where
            $T: std::ops::Mul<Output = $T> + Copy,
        {
            type Output = Vector<$T, LENGTH>;

            /// Perform the `-V` operation.
            fn neg(self) -> Self::Output {
                self * -1 as $T
            }
        }
    )*};
}

impl_neg_trait!(i8, i16, i32, i64, i128, isize, f32, f64);

#[cfg(test)]
mod tests {
    use crate::vector::Vector;

    #[test]
    fn cross_on_basis_vectors() {
        let x: Vector<f32, 3> = v![1.0, 0.0, 0.0];
        let y: Vector<f32, 3> = v![0.0, 1.0, 0.0];
        let z: Vector<f32, 3> = v![0.0, 0.0, 1.0];

        assert_eq!(x.cross(y), z);
        assert_eq!(y.cross(x), -z);
        assert_eq!(y.cross(z), x);
        assert_eq!(z.cross(y), -x);
        assert_eq!(z.cross(x), y);
        assert_eq!(x.cross(z), -y);
    }

    #[test]
    fn negate() {
        assert_eq!(-v![1.0, 2.0, 3.0], v![-1.0, -2.0, -3.0]);
    }
}
