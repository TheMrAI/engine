//! All macro implementations
//!
//! All macro_rules definitions and use should be placed into this file.
//! This way we don't need to handle with the mess of exporting/importing the
//! macros within the crate and the "cycle detected" compiler error.
//! In this error if macro A depends on the code generated by macro B, then the
//! compiler will enter a loop, trying to determine the bounds are satisfied.
//! The issue does not appear if the macro invocations for both A and B appear
//! in the same file.

use crate::matrix::Matrix;

#[macro_export]
macro_rules! m {
    () => {
        $crate::matrix::Matrix::new()
    };
    ($default_value:expr; $cols:expr, $rows:expr) => {
        $crate::matrix::Matrix::<_, $cols, $rows>::from_value($default_value)
    };
    ($($element:expr),+$(,)?) => {
        $crate::matrix::Matrix::from_matrix([$($element),+])
    }
}

// Re-export the macro, avoiding the need for #[macro_use].
pub use m;

// Implement the LHS scalar multiplication operators for built in types.
// For custom types the user must provide the implementation given the Orphan rule.

macro_rules! lhs_scalar_mul_impl {
    ($($T: ty),* $(,)*) => {$(
        impl<const COLS: usize, const ROWS: usize> std::ops::Mul<Matrix<$T, COLS, ROWS>> for $T
        where
            Matrix<$T, COLS, ROWS>: std::ops::Mul<$T, Output = Matrix<$T, COLS, ROWS>>,
        {
            type Output = Matrix<$T, COLS, ROWS>;

            /// Implement `T * Matrix<T>` operation.
            fn mul(self, rhs: Matrix<$T, COLS, ROWS>) -> Self::Output {
                rhs * self
            }
}
    )*};
}

lhs_scalar_mul_impl!(
    u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize, f32, f64
);
